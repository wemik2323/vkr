//Титульный слайд
Здравствуйте, уважаемые члены комиссии.

Вашему вниманию представляется выпускная квалификационная работа на тему:
«Разработка многопользовательской компьютерной игры в жанре RTS „Боярский турнир“».

Работа выполнена под руководством Петровой Ольги Борисовны,
студентом, Хохлов Тихоном Владимировичем.

//Постановка задачи
Целью моей дипломной работы стало создание многопользовательской игры «Боярский Турнир» — стратегии в реальном времени, 
реализованной с применением современных инструментов разработки и подходов к сетевому взаимодействию.
Для достижения этой цели были поставлены следующие задачи:
— Во-первых, реализовать архитектуру с авторитарным сервером, который полностью контролирует игровой процесс и обеспечивает честность сессии;
— Во-вторых, настроить сетевое взаимодействие с использованием протокола QUIC, обеспечивающего быструю и надёжную передачу данных;
— В-третьих, обеспечить синхронизацию игровых состояний между клиентами для корректного отображения текущего положения на поле боя;
— И в-четвёртых, провести сетевой анализ трафика игры с целью оценки эффективности передачи данных и подтверждения корректности архитектурных решений.

//Авторитарный сервер
Для понимания дальнейших технических решений необходимо кратко пояснить, что обозначают эти понятия.

Начну с определения авторитарного сервера.

Авторитарный сервер — это архитектурный подход в клиент-серверных приложениях, 
при котором вся игровая логика и состояние мира полностью обрабатываются и хранятся на сервере, 
а клиенты выполняют лишь роль интерфейса ввода и отображения, не принимая решений самостоятельно.

В авторитарной модели управления игровой логикой сервер выступает единственным источником истины.
Он полностью контролирует состояние мира и все события в нём.
Клиенты лишь отправляют команды: например, запрос на размещение юнита.
Сервер обрабатывает команды, проверяет их на корректность и пересчитывает состояние мира.
Только после этого он рассылает обновлённые данные всем клиентам.

Такой подход исключает возможность расхождений в игровом процессе между игроками и самое главное - защищает от попыток вмешательства или читерства со стороны клиента.

На слайде приведена диаграмма последовательности, иллюстрирующая процесс:
отправка команды клиентом,
обработка на сервере
и возврат синхронизированного состояния всем участникам.

//Основные проблемы протокола TCP
Теперь перейду ко второй технологии, обозначенной среди задач — это протокол QUIC.
Чтобы понять, почему он был выбран, необходимо рассмотреть ограничения традиционного протокола TCP, который до сих пор часто используется в многопользовательских играх.

TCP изначально проектировался для надёжной доставки данных, а не для взаимодействия в реальном времени. Это создаёт ряд проблем в сетевых играх:

Во-первых, тройное рукопожатие — обязательная процедура установления соединения.
На диаграмме видно, что до начала передачи данных требуется обмен тремя пакетами (данная процедура называется тройным рукопожатием). 
Это увеличивает задержку при подключении, особенно при нестабильных сетях.

Во-вторых, TCP не поддерживает мультиплексирование. Все данные передаются строго по порядку, в одном потоке.
Если один пакет задерживается или теряется — дешифровка последующих останавливаются. Это явление называется head-of-line blocking и критично для игр: 
один задержанный пакет блокирует всю очередь.

Также TCP требует ручной поддержки шифрования (например, через TLS), что расширяет это рукопожатие с 3х пакетов до 6.

Все эти проблемы становятся узким местом в разработке динамичных онлайн-игр и требуют альтернативного решения — таким решением стал протокол QUIC.

//Протокол QUIC
В отличие от TCP, QUIC обеспечивает ускоренное установление соединения — на диаграмме видно, что процесс упрощён и требует меньше обмена пакетами. 
Это сокращает задержку при начале сессии.

Кроме того, QUIC поддерживает мультиплексирование потоков — это значит, что данные разных типов и потоков передаются независимо, без блокировки друг друга.
Таким образом, если один пакет задерживается или теряется, остальные продолжают передаваться без задержек. Это решает проблему head-of-line blocking, присущую TCP.

Дополнительно, QUIC имеет встроенное шифрование, надёжно защищая данные и обеспечивая быстрое восстановление соединений при сетевых сбоях.

Использование QUIC позволило улучшить качество сетевого взаимодействия и снизить задержки в игре, что критично для жанра RTS с быстрыми реакциями.

//Clash Royale и Rush Royale
Изначально проект «Боярский Турнир» разрабатывался как функциональная замена Clash Royale —
одной из самых популярных мобильных RTS-игр, задавшей жанровую планку и являвшейся основным конкурентом.

Также в процессе анализа учитывался опыт игры Rush Royale, адаптировавшейся под свой собственный визуальный стиль, темп и геймплей.

После ухода компаний Supercell и MY.GAMES из российского сегмента, официальный доступ к этим играм стал ограниченным.
Тем не менее, спрос на подобные игры остался высоким — игроки продолжают подключаться через VPN, несмотря на снижение качества соединения и рост задержек.

Кроме того, в этих играх используется устаревшая сетевая архитектура, основанная на TCP поверх TLS.
Это ведёт к проблемам с задержкой и откликом, особенно при нестабильной сети, ухудшая пользовательский опыт в реальном времени.

Поэтому потребность в современной, локализованной и технологически актуальной альтернативе стала отправной точкой для разработки игры.

//Выбор инструментов (Rust, Bevy, bevy_quinnet и др.)
Для реализации клиент-серверной многопользовательской игры в данной дипломной работе был выбран язык Rust.

Традиционно в индустрии видеоигр используется язык C++ — он считается стандартом благодаря своей скорости и широкому распространению.
Однако в контексте современных задач, связанных с безопасностью и многопоточностью, Rust показывает себя с лучшей стороны.

В первую очередь, Rust обеспечивает высокую безопасность при работе с памятью и потоками.
Благодаря системе владения и заимствования, язык гарантирует отсутствие гонок данных, утечек памяти и обращений к освобождённой области — и всё это 
без использования сборщика мусора, в отличие от языков высокого уровня.
Подобные ошибки в C++ требуют ручного контроля и могут проявиться только на этапе исполнения.

Также Rust предлагает современный инструментарий.
Менеджер пакетов Cargo и экосистема crates.io значительно упрощают подключение библиотек, управление зависимостями, сборку и тестирование проекта.

//Bevy
Для построения клиентской части игры и реализации всей игровой логики в дипломной работе использован игровой движок Bevy.

Bevy — это современный и активно развивающийся игровой фреймворк на языке Rust. Он предлагает несколько ключевых удобств для разработки:

Во-первых, это архитектура ECS — Entity-Component-System.
Она обеспечивает модульность, читаемость и масштабируемость кода, позволяя легко добавлять новые сущности, 
изменять поведение игровых объектов и разделять ответственность между системами.

Во-вторых, гибкая система плагинов позволяет организовать проект по функциональным модулям: от визуального интерфейса до сетевого взаимодействия, 
что положительно сказывается на поддерживаемости и расширяемости проекта.

Для организации сетевого взаимодействия в рамках проекта была выбрана библиотека bevy_quinnet.
Она предоставляет интеграцию протокола QUIC с Bevy и позволяет реализовать асинхронное и надёжное общение 
между клиентом и сервером, что особенно важно для синхронизации игровых состояний в реальном времени.

//Структура ECS
Для организации игровой логики в проекте используется архитектура ECS — Entity-Component-System.

На слайде представлена схема, отражающая её устройство.

Сущность (Entity) - это просто уникальный идентификатор, не содержащий логики и данных.

Все свойства сущностей представлены в виде компонентов (Components) — небольших структур данных, описывающих конкретные аспекты объекта: 
будь то позиция, здоровье, направление и так далее.

За поведение отвечает система (System) — это логическая единица, которая обрабатывает все сущности, обладающие нужными компонентами.
Например, система атаки обрабатывает только те сущности, у которых есть компонент Атака, Позиция и Цель.

Интересно заметить, что модель ECS концептуально напоминает архитектуру MVC, с которой мы знакомились в курсе по разработке Java-приложений:

Компоненты — это данные, аналог модели.

Системы — логика, аналог контроллера.

Отображение результата на экране — представление (view), которое тоже реализуется как отдельные системы.

//Клиентская часть (интерфейс, игровой процесс)
Перейдём к описанию общей структуры клиентской части игры «Боярский Турнир», а также схема основных компонентов системы.

В левой части слайда изображено дерево каталогов проекта относящихся к приложению клиента.

Каталог assets содержит все игровые ресурсы:
— изображения, анимации (файлы .aseprite), шрифты, звуки.

Каталог boyar_tournament/src/screens/gameplay — основная игровая логика клиента, разбитая по модулям:
— arena.rs отвечает за логику арены и игрового поля;
— deck.rs реализует управление боевой колодой;
— networking.rs обрабатывает сетевые события и коммуникацию с сервером;
— отдельные папки projectiles и units содержат логику поведения снарядов и юнитов соответственно.

В корне каталога boyar_tournament и в соседних папках расположены вспомогательные модули, например, для инструментов разработки (dev_tools.rs) и масштабирования (scaling.rs).

Справа на слайде приведена диаграмма компонентов клиентской системы.
------------------------------------------

//Серверная часть (обработка логики, синхронизация)
Структура серверной части игры представлена проще.

В каталоге server/src расположены ключевые модули:
— main.rs — точка входа сервера, где инициализируются основные системы и запускается игровой цикл;
— networking.rs — отвечает за приём и отправку сетевых сообщений;
— ai.rs — реализует поведение юнитов и снарядов;
— папки units и projectiles содержат логику обработки юнитов и снарядов соответственно, схожую по структуре с клиентом, но с акцентом на серверную валидацию и расчёты.

Схема компонентов сервера, приведённая справа на слайде, показывает разделение подсистем:
----------------------------------------------------

//Сетевое исследование (Wireshark, анализ трафика)
Было проведено исследование сообщения между клиентом и сервером. На слайде представлены графики сетевой активности, измеренной в количестве переданных пакетов в секунду.

Боярский турнир демонстрирует стабильную передачу от 100 до 125 пакетов в секунду. 
Это отражает равномерную и предсказуемую коммуникацию между клиентом и сервером через протокол QUIC. 
Такой паттерн указывает на чётко структурированную синхронизацию состояния игры.

Clash Royale, напротив, показывает резкие скачки от 70 до 1500 пакетов в секунду. 
Это свидетельствует о нерегулярной передаче данных, вызванной особенностями использования TCP и TLS, 
в частности — из-за наличия блокировок передачи.

Rush Royale демонстрирует совершенно иной паттерн: равномерные, одинаковые пики с частотой около 30 пакетов в секунду. 
Такая передача указывает на заранее спланированные, синхронные точки обмена данными, вероятно, завязанные на игровые таймеры.

//Пример работы
В завершении — демонстрация игрового процесса между двумя клиентами.

Все модели и анимации юнитов были отрисованы вручную в пиксельном графическом редакторе Aseprite.

//Выводы
-------------------------------

//Благодарность / Вопросы
--------------------------------